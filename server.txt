import asyncio
import signal
import base64 # <-- YENÄ°
import uuid   # <-- YENÄ° (Dosyaya benzersiz isim vermek iÃ§in)
import username
import websockets
import asyncpg  # <-- YENÄ°: sqlite3 yerine
import json
import os
from fractions import Fraction

import datetime as date
import ssl # <-- BU SATIRI EKLE
import sys
import traceback
import platform
from passlib.context import CryptContext
from pydub import AudioSegment

# --- 1. AYARLAR VE SABÄ°TLER ---
HOST = '0.0.0.0'
PORT = 50505

# --- YENÄ°: PostgreSQL BaÄŸlantÄ± Bilgileri ---
# Faz 1'de oluÅŸturduÄŸunuz kullanÄ±cÄ± adÄ±, ÅŸifre ve veritabanÄ± adÄ±
DB_USER = "chat_user"
DB_PASS = "123456789Apo54.!"  # Kendi ÅŸifreniz
DB_NAME = "chat_app"
DB_HOST = "127.0.0.1"  # Yerel sunucunuz (Radore'da da bu olabilir)
# ---

# GÃ¼venlik SÄ±nÄ±rlarÄ± (AynÄ±)
MAX_USERNAME_LEN = 32
MAX_PASSWORD_LEN = 72
MAX_MESSAGE_LEN = 512
MAX_DM_TARGET_LEN = 32
MAX_AUDIO_SIZE = 1 * 1024 * 1024 # 1 MB ses limiti

try:
    pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
except Exception as e:
    print(f"KRÄ°TÄ°K HATA: passlib/bcrypt yÃ¼klenemedi! Hata: {e}", file=sys.stderr)
    exit()

authenticated_clients = {}

# --- YENÄ°: Global VeritabanÄ± Havuzu ---
DB_POOL = None


# ---

# --- 2. VERÄ°TABANI VE YETKÄ°LENDÄ°RME FONKSÄ°YONLARI (TAMAMEN YENÄ°LENDÄ°) ---

async def setup_database():
    """Sunucu baÅŸlarken tablolarÄ± oluÅŸturur ve 'admin' kullanÄ±cÄ±sÄ±nÄ± tohumlar."""

    # --- YENÄ° BLOK ---
    # Dosya yÃ¼klemeleri iÃ§in klasÃ¶r yapÄ±sÄ±nÄ± oluÅŸtur
    os.makedirs("uploads/audio", exist_ok=True)
    print("Dosya yÃ¼kleme ('uploads/audio') klasÃ¶rÃ¼ kontrol edildi/oluÅŸturuldu.")
    # --- YENÄ° BLOK SONU ---
    # Havuzdan bir baÄŸlantÄ± al
    async with DB_POOL.acquire() as conn:
        # PostgreSQL'in syntax'Ä± (sÃ¶zdizimi) biraz farklÄ±dÄ±r
        # (Ã¶rn: AUTOINCREMENT yerine SERIAL, DATETIME yerine TIMESTAMPTZ)
        await conn.execute('''
                           CREATE TABLE IF NOT EXISTS users
                           (
                               username
                               TEXT
                               PRIMARY
                               KEY
                               NOT
                               NULL,
                               password_hash
                               TEXT
                               NOT
                               NULL,
                               role
                               TEXT
                               NOT
                               NULL
                               DEFAULT
                               'user'
                           )
                           ''')
        await conn.execute('''
                           CREATE TABLE IF NOT EXISTS public_messages
                           (
                               id
                               SERIAL
                               PRIMARY
                               KEY,
                               sender_username
                               TEXT
                               NOT
                               NULL,
                               message_text
                               TEXT
                               NOT
                               NULL,
                               timestamp
                               TIMESTAMPTZ
                               DEFAULT
                               CURRENT_TIMESTAMP
                           )
                           ''')
        await conn.execute(''' CREATE TABLE IF NOT EXISTS private_messages
                               (
                                   id
                                   SERIAL
                                   PRIMARY
                                   KEY,
                                   sender_username
                                   TEXT
                                   NOT
                                   NULL,
                                   target_username
                                   TEXT
                                   NOT
                                   NULL,
                                   message_text
                                   TEXT
                                   NOT
                                   NULL,
                                   timestamp
                                   TIMESTAMPTZ
                                   DEFAULT
                                   CURRENT_TIMESTAMP
                               )''')

        # Admin Tohumlama
        # ... setup_database fonksiyonunun iÃ§i ...
        try:
            admin_user = "admin"
            admin_pass = "123456789Apo54.!"
            hashed_pw = await asyncio.to_thread(hash_password, admin_pass)

            # SQL'i '?' yerine '$1, $2, $3' ile yazdÄ±ÄŸÄ±mÄ±za dikkat et
            # 'ON CONFLICT (username) DO NOTHING' -> 'INSERT OR IGNORE'un Postgres karÅŸÄ±lÄ±ÄŸÄ±
            await conn.execute("""
                               INSERT INTO users (username, password_hash, role)
                               VALUES ($1, $2, $3) ON CONFLICT (username) DO NOTHING
                               """, admin_user, hashed_pw, 'admin')  # <-- DÃœZELTME: BurasÄ± 'admin' olmalÄ±

            print(f"Admin kullanÄ±cÄ±sÄ± '{admin_user}' kontrol edildi/oluÅŸturuldu.")
        except Exception as e:
            print(f"Admin tohumlama sÄ±rasÄ±nda hata: {e}", file=sys.stderr)
        # ...

    print(f"PostgreSQL VeritabanÄ± '{DB_NAME}' ve tablolar hazÄ±r.")


def hash_password(password):
    # Bu CPU-yoÄŸun bir iÅŸlem, 'to_thread' gerektirmez, hÄ±zlÄ± Ã§alÄ±ÅŸÄ±r
    return pwd_context.hash(password)


def verify_password(password, hashed_password):
    # Bu da CPU-yoÄŸun
    try:
        return pwd_context.verify(password, hashed_password)
    except:
        return False


# 'async def' oldu, 'asyncio.to_thread' kalktÄ±
async def register_user(username, password):
    """Yeni bir kullanÄ±cÄ±yÄ± 'user' rolÃ¼yle veritabanÄ±na kaydeder."""

    if not username or not password or len(username) > MAX_USERNAME_LEN or len(
            password.encode('utf-8')) > MAX_PASSWORD_LEN:
        return {"command": "AUTH_FAIL", "payload": "GiriÅŸ bilgileri geÃ§ersiz/Ã§ok uzun."}

    try:
        # Havuzdan bir baÄŸlantÄ± "Ã¶dÃ¼nÃ§ al"
        async with DB_POOL.acquire() as conn:
            # fetchrow -> tek bir satÄ±r getir
            existing_user = await conn.fetchrow("SELECT username FROM users WHERE username = $1", username)
            if existing_user:
                return {"command": "AUTH_FAIL", "payload": "KullanÄ±cÄ± adÄ± zaten alÄ±nmÄ±ÅŸ."}

            new_role = 'user'
            hashed_pw = await asyncio.to_thread(hash_password, password)

            await conn.execute("INSERT INTO users (username, password_hash, role) VALUES ($1, $2, $3)",
                               username, hashed_pw, new_role)

        print(f"Yeni kullanÄ±cÄ± kayÄ±t oldu: {username} (Rol: {new_role})")
        return {"command": "REGISTER_SUCCESS", "payload": "KayÄ±t baÅŸarÄ±lÄ±. Åimdi giriÅŸ yapabilirsiniz."}

    except Exception as e:
        print(f"REGISTER_USER HATASI: {e}", file=sys.stderr)
        traceback.print_exc(file=sys.stderr)
        return {"command": "AUTH_FAIL", "payload": f"Sunucu veritabanÄ± hatasÄ±"}


# 'async def' oldu, 'asyncio.to_thread' kalktÄ±
async def check_login(username, password):
    """KullanÄ±cÄ±yÄ± doÄŸrular ve 'role' bilgisini de dÃ¶ndÃ¼rÃ¼r."""

    if not username or not password or len(username) > MAX_USERNAME_LEN:
        return {"command": "AUTH_FAIL", "payload": "GiriÅŸ bilgileri geÃ§ersiz."}, None, None

    try:
        async with DB_POOL.acquire() as conn:
            result = await conn.fetchrow("SELECT username, password_hash, role FROM users WHERE username = $1", username)

        if not result:
            return {"command": "AUTH_FAIL", "payload": "KullanÄ±cÄ± bulunamadÄ±."}, None, None

    # asyncpg satÄ±rlarÄ± sÃ¶zlÃ¼k gibi dÃ¶ndÃ¼rÃ¼r (sÃ¼tun adÄ±yla eriÅŸim harikadÄ±r)
        hashed_pw_from_db = result['password_hash']
        if isinstance(hashed_pw_from_db, bytes):  # bytea dÃ¶nÃ¼ÅŸÃ¼nÃ¼ engelle
            hashed_pw_from_db = hashed_pw_from_db.decode('utf-8')
        user_role = result['role']

        if await asyncio.to_thread(verify_password, password, hashed_pw_from_db):
            return {"command": "AUTH_SUCCESS", "payload": "GiriÅŸ baÅŸarÄ±lÄ±."}, username, user_role
        else:
            return {"command": "AUTH_FAIL", "payload": "YanlÄ±ÅŸ ÅŸifre."}, None, None
    except Exception as e:
        print(f"CHECK_LOGIN HATASI: {e}", file=sys.stderr)
        traceback.print_exc(file=sys.stderr)
        return {"command": "AUTH_FAIL", "payload": f"GiriÅŸ hatasÄ±: {e}"}, None, None


# --- 3. ASENKRON AÄ VE YÃ–NETÄ°M FONKSÄ°YONLARI ---

async def broadcast(message_json, exclude_websocket=None):
    if authenticated_clients:
        message_str = json.dumps(message_json)
        tasks = []
        for websocket in authenticated_clients.keys():
            if websocket != exclude_websocket:
                # websocket.send'in bir istisna (exception) fÄ±rlatmasÄ± durumunda
                # gather'Ä±n Ã§Ã¶kmemesi iÃ§in 'shield' kullanÄ±labilir, ama basit tutalÄ±m.
                tasks.append(websocket.send(message_str))

        # return_exceptions=True, bir baÄŸlantÄ± koptuÄŸunda diÄŸerlerinin devam etmesini saÄŸlar
        await asyncio.gather(*tasks, return_exceptions=True)


async def broadcast_user_list(exclude_websocket=None):
    if not authenticated_clients: return
    user_list_payload = list(authenticated_clients.values())
    message_json = {"command": "USER_LIST_UPDATE", "payload": user_list_payload}
    await broadcast(message_json, exclude_websocket=exclude_websocket)


async def handle_dm(sender_username, target_username, message_text):
    target_socket = None;
    sender_socket = None

    try:
        async with DB_POOL.acquire() as conn:
            await conn.execute(
                "INSERT INTO private_messages (sender_username, target_username, message_text) VALUES ($1, $2, $3)",
                sender_username, target_username, message_text
            )
    except Exception as e:
        print(f"DM veritabanÄ±na kaydedilemedi: {e}", file=sys.stderr)

    # .items() kopyasÄ± Ã¼zerinde dÃ¶nmek, dÃ¶ngÃ¼ sÄ±rasÄ±nda deÄŸiÅŸiklik yapmaya izin verir
    for socket, data in list(authenticated_clients.items()):
        if data["username"] == target_username: target_socket = socket
        if data["username"] == sender_username: sender_socket = socket

    dm_to_target = {"command": "DM", "payload": f"[{sender_username} -> Siz]: {message_text}"}
    dm_to_sender = {"command": "DM", "payload": f"[Siz -> {target_username}]: {message_text}"}

    tasks = []
    if target_socket:
        tasks.append(target_socket.send(json.dumps(dm_to_target)))
        if sender_socket: tasks.append(sender_socket.send(json.dumps(dm_to_sender)))
    else:
        if sender_socket:
            error_msg = {"command": "SYS_MSG_ERR", "payload": f"Hata: '{target_username}' kullanÄ±cÄ±sÄ± Ã§evrimiÃ§i deÄŸil."}
            tasks.append(sender_socket.send(json.dumps(error_msg)))

    if tasks: await asyncio.gather(*tasks, return_exceptions=True)



# KayÄ±t dizini
AUDIO_SAVE_DIR = "audio_records"
os.makedirs(AUDIO_SAVE_DIR, exist_ok=True)

async def broadcast_audio(audio_chunk, sender_username=None, exclude_websocket=None):
    """
    Ä°kili (binary) ses parÃ§asÄ±nÄ± herkese yayÄ±nlar ve kaydeder.
    """
    # 1ï¸âƒ£ Dosya kaydÄ±
    if sender_username:
        filename = os.path.join(AUDIO_SAVE_DIR, f"{sender_username}_{int(date.datetime.now().timestamp())}.raw")
        try:
            with open(filename, "ab") as f:
                f.write(audio_chunk)
        except Exception as e:
            print(f"Ses kaydedilemedi: {e}", file=sys.stderr)

    # 2ï¸âƒ£ CanlÄ± broadcast
    tasks = []
    for websocket in authenticated_clients.keys():
        if websocket != exclude_websocket:
            tasks.append(websocket.send(audio_chunk))
    await asyncio.gather(*tasks, return_exceptions=True)

    # 3ï¸âƒ£ Chat mesajÄ± olarak broadcast (opsiyonel)
    if sender_username:
        timestamp = date.datetime.now().strftime("%H:%M")
        formatted_message = {
            "command": "CHAT",
            "payload": f"[{timestamp} - {sender_username}]: Ses mesajÄ± gÃ¶nderildi ğŸ¤"
        }
        await broadcast(formatted_message, exclude_websocket=None)



async def broadcast_audio_status(username, status, exclude_websocket=None):
    """KullanÄ±cÄ±nÄ±n ses kaydetme durumunu herkese duyurur."""
    if status == "started":
        msg = f"[{username}] ses kaydetmeye baÅŸladÄ±."
    else:
        msg = f"[{username}] ses kaydÄ±nÄ± bitirdi."
    message_json = {"command": "SYS_MSG", "payload": msg}
    await broadcast(message_json, exclude_websocket=exclude_websocket)


async def handle_kick(admin_username, target_username, admin_websocket):
    if admin_username == target_username:
        error_msg = {"command": "SYS_MSG_ERR", "payload": "Kendinizi atamazsÄ±nÄ±z."};
        await admin_websocket.send(json.dumps(error_msg));
        return

    target_socket = None;
    target_role = None
    for socket, data in authenticated_clients.items():
        if data["username"] == target_username: target_socket = socket; target_role = data.get("role"); break

    if not target_socket:
        error_msg = {"command": "SYS_MSG_ERR", "payload": f"KullanÄ±cÄ± '{target_username}' bulunamadÄ±."};
        await admin_websocket.send(json.dumps(error_msg));
        return
    if target_role == 'admin':
        error_msg = {"command": "SYS_MSG_ERR", "payload": "BaÅŸka bir Admin'i atamazsÄ±nÄ±z."};
        await admin_websocket.send(json.dumps(error_msg));
        return

    try:
        kick_msg_to_target = {"command": "KICK_SIGNAL",
                              "payload": "Sunucudan bir admin tarafÄ±ndan atÄ±ldÄ±nÄ±z. GiriÅŸ ekranÄ±na yÃ¶nlendiriliyorsunuz..."}
        await target_socket.send(json.dumps(kick_msg_to_target))
        success_msg_to_admin = {"command": "SYS_MSG", "payload": f"'{target_username}' kullanÄ±cÄ±sÄ± baÅŸarÄ±yla atÄ±ldÄ±."}

        try:
            await admin_websocket.send(json.dumps(success_msg_to_admin))
        except:
            pass  # Adminin baÄŸlantÄ±sÄ± da koptuysa gÃ¶rmezden gel

        await asyncio.sleep(0.05)  # MesajÄ±n gitmesi iÃ§in zaman tanÄ±
        await target_socket.close(code=1000, reason="Kicked by admin")

    except Exception as e:
        print(f"Kick iÅŸlemi sÄ±rasÄ±nda hata: {e}", file=sys.stderr)
        try:
            error_msg = {"command": "SYS_MSG_ERR", "payload": "KullanÄ±cÄ± atÄ±lÄ±rken bir hata oluÅŸtu."};
            await admin_websocket.send(json.dumps(error_msg))
        except:
            pass


# --- 4. ANA Ä°ÅLEYÄ°CÄ° 'HANDLER' (GÃœNCELLENDÄ°) ---

async def handler(websocket):
    """Her WebSocket baÄŸlantÄ±sÄ±nÄ± yÃ¶neten ana asenkron fonksiyon."""

    current_username = None;
    current_role = None
    AUDIO_DIR = "audio_records"
    os.makedirs(AUDIO_DIR, exist_ok=True)
    user_audio_chunks = []  # websocket scope

    try:
        # --- AÅAMA 1: KÄ°MLÄ°K DOÄRULAMA DÃ–NGÃœSÃœ ---
        async for message in websocket:
            try:
                data = json.loads(message); command = data.get("command"); payload = data.get("payload", {})
            except json.JSONDecodeError:
                continue

            response_json = {}
            if command == "REGISTER":
                # 'to_thread' GÄ°TTÄ°, yerine 'await' GELDÄ°
                response_json = await register_user(payload.get("user"), payload.get("pass"))

            elif command == "LOGIN":
                user = payload.get("user");
                pwd = payload.get("pass")
                if user in [data['username'] for data in authenticated_clients.values()]:
                    response_json = {"command": "AUTH_FAIL", "payload": "Bu kullanÄ±cÄ± zaten baÄŸlÄ±."}
                else:
                    # 'to_thread' GÄ°TTÄ°, yerine 'await' GELDÄ°
                    response_json, auth_username, auth_role = await check_login(user, pwd)

                    if response_json.get("command") == "AUTH_SUCCESS":
                        current_username = auth_username;
                        current_role = auth_role
                        authenticated_clients[websocket] = {"username": current_username, "role": current_role}

                        # --- LOGIN_DATA_PACKAGE GÃ–NDERÄ°MÄ° ---
                        # 'to_thread' GÄ°TTÄ°, yerine 'await' GELDÄ°
                        history_payload = []
                        try:
                            async with DB_POOL.acquire() as conn:
                                # PostgreSQL'de saat dilimi (timezone) yÃ¶netimi Ã¶nemlidir.
                                # 'Europe/Istanbul' (GMT+3) olarak varsayÄ±yoruz.
                                # Sunucunuz (Radore) farklÄ± bir saat dilimindeyse, bunu ayarlamanÄ±z gerekir.
                                history_rows = await conn.fetch(
                                    "SELECT sender_username, message_text, (timestamp AT TIME ZONE 'UTC' AT TIME ZONE 'Europe/Istanbul')::TIMESTAMP(0)::TEXT AS timestamp FROM public_messages ORDER BY timestamp DESC LIMIT 20"
                                )

                            dm_history = [f"[{row['timestamp']} - {row['sender_username']}]: {row['message_text']}" for
                                          row in history_rows]

                            history_rows.reverse()
                            # fetchrow 'Record' objesi dÃ¶ndÃ¼rÃ¼r, 'row[0]' yerine 'row['sender_username']' kullanÄ±labilir
                            history_payload = [f"[{row['timestamp']} - {row['sender_username']}]: {row['message_text']}"
                                               for row in history_rows]
                        except Exception as e:
                            print(f"Sohbet geÃ§miÅŸi yÃ¼klenirken hata: {e}", file=sys.stderr)

                        user_list = list(authenticated_clients.values())

                        login_data_package = {"command": "LOGIN_DATA_PACKAGE",
                                              "payload": {"username": current_username, "role": current_role,
                                                          "history": history_payload, "user_list": user_list}}
                        await websocket.send(json.dumps(login_data_package))
                        print(f"GiriÅŸ baÅŸarÄ±lÄ±: {current_username} (Rol: {current_role}).")
                        break

            else:
                response_json = {"command": "AUTH_FAIL", "payload": "GeÃ§ersiz komut."}
            if response_json:
                await websocket.send(json.dumps(response_json))

                # --- YENÄ° EKLENEN BLOK ---
                # EÄŸer yanÄ±t bir 'HATA' ise, istemciyi sÄ±fÄ±rlamaya zorla
                if "FAIL" in response_json.get("command", ""):
                    print(f"DEBUG: Kimlik doÄŸrulama baÅŸarÄ±sÄ±z, baÄŸlantÄ± kapatÄ±lÄ±yor.")
                    await websocket.close(code=1000, reason="Authentication failed")
                    break  # Kimlik doÄŸrulama dÃ¶ngÃ¼sÃ¼nden Ã§Ä±k
                # --- YENÄ° BLOK SONU ---

            if not current_username:
                return

        # --- AÅAMA 2: SOHBET DÃ–NGÃœSÃœ ---
        join_msg = {"command": "SYS_MSG", "payload": f"[{current_username}] sohbete katÄ±ldÄ±!"};
        await broadcast(join_msg, exclude_websocket=websocket);
        await broadcast_user_list(exclude_websocket=websocket)

        # --- Handler iÃ§inde websocket scope ---
        AUDIO_SAVE_DIR = "audio_records"
        os.makedirs(AUDIO_SAVE_DIR, exist_ok=True)
        user_audio_buffer = []  # sadece bu websocket iÃ§in buffer

        # --- AÅAMA 2: SOHBET DÃ–NGÃœSÃœ (NÄ°HAÄ° - DÃœZELTÄ°LMÄ°Å) ---
        join_msg = {"command": "SYS_MSG", "payload": f"[{current_username}] sohbete katÄ±ldÄ±!"};
        await broadcast(join_msg, exclude_websocket=websocket);
        await broadcast_user_list(exclude_websocket=websocket)

        async for message in websocket:

            # 1. Gelen veri ikili (ses) ise (v4.0 "Telsiz" Modeli)
            if isinstance(message, bytes):
                if current_role == 'admin':
                    await websocket.send(
                        json.dumps({"command": "SYS_MSG_ERR", "payload": "Admin hesabÄ± ile ses gÃ¶nderilemez."}));
                    continue
                # await broadcast_audio(message, exclude_websocket=websocket); # CanlÄ± yayÄ±nÄ± kapattÄ±k, v4.1'e odaklan
                continue  # Åimdilik ikili veriyi gÃ¶rmezden gel

            # 2. Gelen veri metin (JSON) ise
            try:
                data = json.loads(message); command = data.get("command"); payload = data.get("payload", {})
            except json.JSONDecodeError:
                continue

            # --- TÃœM KOMUTLARIN LÄ°STESÄ° (DOÄRU HÄ°ZALANMIÅ) ---

            if command == "CHAT":
                message_text = payload.get("message");
                if not message_text or len(message_text) > MAX_MESSAGE_LEN: continue
                try:
                    async with DB_POOL.acquire() as conn:
                        await conn.execute(
                            "INSERT INTO public_messages (sender_username, message_text) VALUES ($1, $2)",
                            current_username, message_text)
                except Exception as e:
                    print(f"Mesaj veritabanÄ±na kaydedilemedi: {e}", file=sys.stderr)
                timestamp = date.datetime.now().strftime('%H:%M');
                formatted_message = {"command": "CHAT",
                                     "payload": f"[{timestamp} - {current_username}]: {message_text}"};
                await broadcast(formatted_message)


            elif command == "FETCH_DM_HISTORY":
                target_user = payload.get("target")
                if not target_user:
                    continue

                print(f"DEBUG: {current_username} kullanÄ±cÄ±sÄ± {target_user} ile olan DM geÃ§miÅŸini istedi.")

                try:
                    history_payload = []
                    async with DB_POOL.acquire() as conn:
                        # Hem gÃ¶nderen 'ben' alÄ±cÄ± 'hedef' olanlarÄ±,
                        # hem de gÃ¶nderen 'hedef' alÄ±cÄ± 'ben' olanlarÄ± Ã§ek
                        # ve tarihe gÃ¶re eskiden yeniye sÄ±rala
                        history_rows = await conn.fetch(
                            """
                            SELECT sender_username,
                                   target_username,
                                   message_text,
                                   (timestamp AT TIME ZONE 'UTC' AT TIME ZONE 'Europe/Istanbul') ::TIMESTAMP(0)::TEXT AS timestamp
                            FROM private_messages
                            WHERE (sender_username = $1
                              AND target_username = $2)
                               OR (sender_username = $2
                              AND target_username = $1)
                            ORDER BY timestamp ASC
                                LIMIT 50
                            """,
                            current_username, target_user
                        )

                        # MesajlarÄ± istemcinin beklediÄŸi formata dÃ¶nÃ¼ÅŸtÃ¼r [cite: 120-125]
                        for row in history_rows:
                            sender = row['sender_username']
                            target = row['target_username']
                            msg = row['message_text']
                            ts = row['timestamp']  # Sorguda formatladÄ±k [cite: 286]

                            if sender == current_username:
                                formatted_msg = f"[{ts}] [Siz -> {target}]: {msg}"
                            else:
                                formatted_msg = f"[{ts}] [{sender} -> Siz]: {msg}"

                            history_payload.append(formatted_msg)

                    # Ä°stemcinin "DM_HISTORY" komutuna yanÄ±t ver [cite: 117]
                    response = {
                        "command": "DM_HISTORY",
                        "payload": {
                            "target": target_user,
                            "messages": history_payload
                        }
                    }
                    await websocket.send(json.dumps(response))

                except Exception as e:
                    print(f"DM GeÃ§miÅŸi alÄ±nÄ±rken hata: {e}", file=sys.stderr)
                    traceback.print_exc(file=sys.stderr)
                # --- YENÄ° EKLENTÄ° SONU ---



            elif command == "DM":
                target_user = payload.get("target");
                message_text = payload.get("message")
                if not target_user or not message_text or len(message_text) > MAX_MESSAGE_LEN or len(
                    target_user) > MAX_DM_TARGET_LEN: continue
                await handle_dm(current_username, target_user, message_text)

            elif command == "TYPING_START":
                await broadcast({"command": "TYPING_START", "payload": current_username}, exclude_websocket=websocket)
            elif command == "TYPING_STOP":
                await broadcast({"command": "TYPING_STOP", "payload": current_username}, exclude_websocket=websocket)

            elif command == "KICK":
                if current_role == 'admin':
                    await handle_kick(current_username, payload.get("target"), websocket)
                else:
                    error_msg = {"command": "SYS_MSG_ERR",
                                 "payload": "Bu komutu kullanma yetkiniz yok."}; await websocket.send(
                        json.dumps(error_msg))

            # --- v4.1 (DOSYA YÃœKLEME) KOMUTLARI ---

            elif command == "AUDIO_MSG":  # <-- BLOK 1
                try:
                    filedata_b64 = payload.get("filedata_b64");
                    file_format = payload.get("format", "mp3");
                    duration = payload.get("duration_seconds", 0)
                    if not filedata_b64: continue

                    # 1. Veriyi Ã§Ã¶z ve kaydet
                    audio_bytes = base64.b64decode(filedata_b64)
                    if len(audio_bytes) > MAX_AUDIO_SIZE:
                        await websocket.send(json.dumps(
                            {"command": "SYS_MSG_ERR", "payload": f"Ses dosyasÄ± Ã§ok bÃ¼yÃ¼k (Maks {MAX_AUDIO_SIZE}MB)."}))
                        continue

                    # 2. Benzersiz dosya adÄ± oluÅŸtur ve kaydet
                    file_id = f"{uuid.uuid4()}.{file_format}";
                    save_path = os.path.join("uploads", "audio", file_id)
                    with open(save_path, "wb") as f:
                        f.write(audio_bytes)

                    # 3. Herkese "CHAT" mesajÄ± olarak yayÄ±nla
                    print(f"Sesli mesaj alÄ±ndÄ±: {current_username} -> {file_id}")
                    timestamp = date.datetime.now().strftime('%H:%M')
                    message_text = f"[â–¶ï¸ Sesli Mesaj ({duration:.1f}s) - ID: {file_id}]"
                    formatted_message = {"command": "CHAT",
                                         "payload": f"[{timestamp} - {current_username}]: {message_text}"};
                    await broadcast(formatted_message)

                except Exception as e:
                    print(f"Sesli mesaj iÅŸlenirken hata: {e}", file=sys.stderr)
                    await websocket.send(
                        json.dumps({"command": "SYS_MSG_ERR", "payload": "Sesli mesajÄ±nÄ±z iÅŸlenemedi."}))

            elif command == "FETCH_AUDIO":  # <-- BLOK 2 (ARTIK AYNI HÄ°ZADA)
                try:
                    file_id = payload.get("file_id");
                    if not file_id: continue
                    base_dir = os.path.abspath("uploads/audio");
                    file_path = os.path.abspath(os.path.join(base_dir, file_id))
                    if os.path.commonprefix((file_path, base_dir)) != base_dir: raise Exception(
                        "GÃ¼venlik ihlali: Ä°zin verilmeyen dosya yolu.")
                    if not os.path.exists(file_path):
                        await websocket.send(
                            json.dumps({"command": "SYS_MSG_ERR", "payload": "Ses dosyasÄ± sunucuda bulunamadÄ±."}));
                        continue

                    with open(file_path, "rb") as f:
                        audio_data_bytes = f.read()

                    audio_base64 = base64.b64encode(audio_data_bytes).decode('utf-8')
                    message_json = {"command": "AUDIO_DATA",
                                    "payload": {"file_id": file_id, "filedata_b64": audio_base64}}
                    await websocket.send(json.dumps(message_json))

                except Exception as e:
                    print(f"Ses dosyasÄ± gÃ¶nderilirken hata: {e}", file=sys.stderr)
                    await websocket.send(
                        json.dumps({"command": "SYS_MSG_ERR", "payload": f"Ses dosyasÄ± alÄ±namadÄ±: {e}"}))
            # --- GÃ–RÃœNTÃœLÃœ ARAMA / WEBRTC SÄ°NYAL YÃ–NLENDÄ°RME (TEMÄ°Z BLOK) ---
            elif command in (
                    "CALL_REQUEST", "CALL_ACCEPT", "CALL_REJECT",
                    "CALL_OFFER", "CALL_ANSWER", "CALL_CANDIDATE",
                    "CALL_ENDED", "VIDEO_REQUEST", "VIDEO_ACCEPT",
                    "VIDEO_REJECT", "VIDEO_ENDED"
            ):
                try:
                    target_username = payload.get("target")
                    if not target_username:
                        print(f"DEBUG ({current_username}): Sinyal atlandÄ± (target eksik).")
                        continue

                    # Hedef websocket'i bul
                    target_socket = next((ws for ws, d in authenticated_clients.items()
                                          if d.get("username") == target_username), None)

                    if not target_socket:
                        # KarÅŸÄ± taraf Ã§evrimdÄ±ÅŸÄ±ysa
                        await websocket.send(json.dumps({
                            "command": "SYS_MSG_ERR",
                            "payload": f"{target_username} ÅŸu anda Ã§evrimdÄ±ÅŸÄ±."
                        }))
                        print(f"DEBUG ({current_username}): {command} -> {target_username} baÅŸarÄ±sÄ±z (offline).")
                        continue

                    # Relay edilecek payload'u hazÄ±rla
                    relay_payload = payload.copy()
                    relay_payload["from"] = current_username

                    # KarÅŸÄ± tarafa gÃ¶nder
                    await target_socket.send(json.dumps({
                        "command": command,
                        "payload": relay_payload
                    }))

                    print(
                        f"DEBUG ({current_username}): {command} sinyali {target_username} kullanÄ±cÄ±sÄ±na yÃ¶nlendirildi.")

                except Exception as e:
                    print(f"DEBUG ({current_username}): WebRTC relay hatasÄ±: {e}", file=sys.stderr)


            elif command == "KEY_INIT":
                target = payload.get("target")
                pub = payload.get("pub");
                salt = payload.get("salt")
                target_socket = next((s for s, d in authenticated_clients.items() if d["username"] == target), None)
                if target_socket:
                        await target_socket.send(json.dumps({"command": "KEY_INIT",
                                                             "payload": {"from_user": current_username, "pub": pub,
                                                                         "salt": salt}}))

            elif command == "KEY_REPLY":
                target = payload.get("target")
                pub = payload.get("pub");
                salt = payload.get("salt")
                target_socket = next((s for s, d in authenticated_clients.items() if d["username"] == target), None)
                if target_socket:
                        await target_socket.send(json.dumps({"command": "KEY_REPLY",
                                                             "payload": {"from_user": current_username, "pub": pub,
                                                                         "salt": salt}}))

            elif command == "ENC_MSG":
                    # DM or public depending on presence of 'target'
                target = payload.get("target")
                env = {
                        "command": "ENC_MSG",
                        "payload": {
                            "from_user": current_username,
                            "nonce": payload.get("nonce"),
                            "salt": payload.get("salt"),
                            "ct": payload.get("ct"),
                            "aad": payload.get("aad"),
                        }
                }
                if target:
                    target_socket = next((s for s, d in authenticated_clients.items() if d["username"] == target),
                                             None)
                    if target_socket:
                            await target_socket.send(json.dumps(env))
                else:
                        await broadcast(env)





            # --- DiÄŸer Komutlar ---
            else:
                print(f"Bilinmeyen komut alÄ±ndÄ± ({current_username}): {command}")

    except (websockets.exceptions.ConnectionClosedOK, websockets.exceptions.ConnectionClosedError):
        pass  # BaÄŸlantÄ± kapandÄ±ÄŸÄ±nda (kick, quit) sessizce Ã§Ä±k
    except Exception as e:
        print(f"handler iÃ§inde HATA ({current_username}): {e}", file=sys.stderr)
        traceback.print_exc(file=sys.stderr)

    finally:
        if websocket in authenticated_clients:
            username = authenticated_clients.pop(websocket)["username"]
            print(f"'{username}' kullanÄ±cÄ±sÄ±nÄ±n baÄŸlantÄ±sÄ± kesildi.")
            leave_msg = {"command": "SYS_MSG", "payload": f"[{username}] sohbetten ayrÄ±ldÄ±."};
            await broadcast(leave_msg);
            await broadcast_user_list()
            stop_msg = {"command": "TYPING_STOP", "payload": username};
            await broadcast(stop_msg)


# 'main' fonksiyonunun TAMAMINI bununla deÄŸiÅŸtir:

async def main():
    global DB_POOL

    stop_event = asyncio.Event()

    # --- 1. Windows dÄ±ÅŸÄ±ndaki sistemlerde sinyal iÅŸleyicisi
    loop = asyncio.get_running_loop()

    if platform.system() != "Windows":
        def _on_signal():
            print("\nSinyal alÄ±ndÄ±: kapanma baÅŸlatÄ±lÄ±yor...")
            stop_event.set()

        for s in (signal.SIGINT, signal.SIGTERM):
            try:
                loop.add_signal_handler(s, _on_signal)
            except NotImplementedError:
                pass

    # --- 2. VeritabanÄ± baÄŸlantÄ±sÄ±
    try:
        DB_POOL = await asyncpg.create_pool(
            user=DB_USER,
            password=DB_PASS,
            database=DB_NAME,
            host=DB_HOST
        )
        print("âœ… VeritabanÄ± baÄŸlantÄ±sÄ± kuruldu.")
    except Exception as e:
        print(f"âŒ VeritabanÄ±na baÄŸlanÄ±lamadÄ±: {e}", file=sys.stderr)
        traceback.print_exc()
        return

    # --- 3. SSL ayarlarÄ±
    ssl_context = None
    try:
        ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
        ssl_context.load_cert_chain("certs/cert.pem", "certs/key.pem")
        print("ğŸ”’ SSL sertifikasÄ± yÃ¼klendi.")
    except FileNotFoundError:
        print("âš ï¸ SSL devre dÄ±ÅŸÄ±: 'certs/' klasÃ¶rÃ¼nde sertifika bulunamadÄ±.")
        ssl_context = None

    # --- 4. WebSocket sunucusu baÅŸlat
    try:
        server = await websockets.serve(handler, HOST, PORT, ssl=ssl_context)
    except Exception as e:
        print(f"âŒ Websocket baÅŸlatma hatasÄ±: {e}", file=sys.stderr)
        traceback.print_exc()
        await DB_POOL.close()
        return

    print(f"âœ… Sunucu {HOST}:{PORT} adresinde Ã§alÄ±ÅŸÄ±yor. (Ctrl+C ile durdur)")

    # --- 5. Ana dÃ¶ngÃ¼: Ctrl+C bekle
    try:
        # Windows'ta KeyboardInterrupt ile manuel yakalama
        while not stop_event.is_set():
            await asyncio.sleep(0.1)
    except KeyboardInterrupt:
        print("\nğŸ›‘ Ctrl+C alÄ±ndÄ±, kapatma iÅŸlemi baÅŸlatÄ±lÄ±yor...")
        stop_event.set()
    finally:
        print("ğŸ”» Sunucu kapatÄ±lÄ±yor...")

        try:
            server.close()
            await server.wait_closed()
            print("âœ… WebSocket sunucusu kapatÄ±ldÄ±.")
        except Exception as e:
            print(f"Sunucu kapatÄ±lÄ±rken hata: {e}", file=sys.stderr)

        try:
            if DB_POOL:
                await DB_POOL.close()
                print("âœ… VeritabanÄ± baÄŸlantÄ± havuzu kapatÄ±ldÄ±.")
        except Exception as e:
            print(f"DB kapatÄ±lÄ±rken hata: {e}", file=sys.stderr)

        print("ğŸ§¹ Temizlik tamamlandÄ±. Program gÃ¼venli ÅŸekilde sonlandÄ±.")

if __name__ == "__main__":
    # Windows iÃ§in loop politikasÄ±
    if platform.system() == "Windows":
        try:
            asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
        except Exception:
            pass

    try:
        asyncio.run(main())
    except Exception as e:
        print(f"Program baÅŸlatÄ±lÄ±rken hata: {e}", file=sys.stderr)
        traceback.print_exc()
    finally:
        print("ğŸ’¤ Programdan Ã§Ä±kÄ±lÄ±yor...")